\section{Implementation}
\label{sec:implementation}


We used C++ class templates to create a application independent random forest implementation. Thus, it would be possible apply it with arbitrary label and data types. Based on that, we developed the code to solve our particular problem, namely the detection of cell boundaries of a ventral nerve cord of the early Drosophila larva. Given this case, we differentiate between the labels \emph{Border} and \emph{Cell} and use the typical OpenCV class for image storage (\texttt{cv::Mat}) as data type.\\
The majority of our implementation can be divided into the label and data type independent \emph{Base} part and the problem specific \emph{Cell} part. Additionally, you will find some helpful pieces of code for basic file and image operations. We used several boost libraries\footnote{\texttt{system filesystem random regex program\_options}} to ensure code quality.\\
In the following we are going to describe the two major parts in detail.

\subsection{Base}
\label{subsec:base}
We developed a simple forest. It consist of a set of trees. Each tree holds a root node and each node holds a right and a left child. 


\subsection{Cell}
\label{subsec:base}


\subsection{Tests}
As already described the NodeFactorys- and Node-derivertives make it possible to implement different data dependent tests easily. Therefore only a NodeFactory and a Node has to be implemented, where each node performs a test in the weak learner model.
For performance reasons each patch is available as intensity-, gradient, integral intensity-, and integral gradient-image. The different representations are calculated in the beginning and stored in the different channels of an cv::Mat (RGBA).

Note that all thresholds are chosen randomly, as well as the origin and the width and hight, if not stated differently.

\FloatBarrier
\begin{description}
\item[CenterPixel:]
This test compares a the intensity of the center pixel with an arbitrary pixel within the patch.

\item[TwoPixel:]
Here two arbitrary pixel intensities within the patch are subtracted and compared to n threshold.

\item[GradientNode:]
The sum of pixel intensities of the whole gradient patch is compared to a threshold. For performance reasons an integral image is used. 

\item[TwoPixelGradient:]
Here 5 arbitrary gradient pixels are compared with 5 other ones and average is again thresholded.

\item[TwoRegions:]
The difference of means of two randomly chosen regions are thresholded. Again the integral image is used.

\item[TwoRegionsGradient:]
Two regions are randomly chosen and the mean of the pixelwise subtraction is thresholded. Note that here the gradient magnetude is used not the integral image.

\item[Sum:]
The sum of pixel intensities over the whole image patch is compared to a threshold. For performance reasons an integral image is used.

\item[HaarWavelet:]
First the patches sum is calculated. After that the sum of a region is calculated. This region is either vertical or horizontal oriented (chosen randomly). In vertical case the region is placed in the lower half of the patch, while horizontal is placed in the right half of the patch. Aim of the regions are to subtract on half of the other. Finally the double of the difference can again subtracted of the patch sum.

\item[SURFFilter:]
This filter uses a kind of SURF feature. The integral image is used for performance reasons. First the sum of the patch intensity is calculated. After that, either a vertical or horizontal (randomly chosen) centered regions is determined. The difference of the patch sum minus the double of the centered region is finally thresholded. In this case the regions is not random, but a third of the patch size.
\end{description}



